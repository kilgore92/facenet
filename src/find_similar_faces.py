"""

Using the dictionary generated by the distance calculation script,
find top-n similar images from the training set for each test set image

"""
import scipy.misc
import pickle
import os
import numpy as np
import collections

def center_crop(im, output_size):
    output_height, output_width = output_size
    h, w = im.shape[:2]
    short_edge = min(h,w)
    if h < output_height and w < output_width:
        raise ValueError("image is small")

    offset_h = int((h - short_edge) / 2)
    offset_w = int((w - short_edge) / 2)
    center_crop =  im[offset_h:offset_h+short_edge, offset_w:offset_w+short_edge, :]
    resized_crop = scipy.misc.imresize(center_crop,[output_width+18,output_height+18]) # Add some wiggle room
    start_pixel = 10
    end_pixel = output_width + 10 # Assuming that width and height are same !!
    centered_image = resized_crop[start_pixel:end_pixel,start_pixel:end_pixel]
    return centered_image

def fetch_dict(fname):
    try:
        with open(fname,'rb') as f:
            return collections.OrderedDict(sorted(pickle.load(f).items()))
    except:
        print('Pkl file not found')


def read_and_crop_image(fname):
    return center_crop(im = scipy.misc.imread(name=fname,mode='RGB'),output_size=[64,64])


def merge_and_save(image_list,idx,root_dir):

    if os.path.exists(root_dir) is False:
        os.makedirs(root_dir)

    filename = os.path.join(root_dir,'sim_images_for_{}.jpg'.format(idx))
    frame_width = 64*len(image_list)
    frame_height = 64
    frame_channels = 3
    img = np.zeros((frame_height,frame_width,frame_channels))
    for image,idx in zip(image_list,range(len(image_list))):
        x_pos = idx*64
        img[:,x_pos:x_pos+64,:] = image
    scipy.misc.imsave(filename,img)


def find_similar_faces(distance_dict,top_n=10):
    """
    distance_dict = {test_image_path : {training_image_path : distance}}

    """
    root_dir = os.path.join(os.getcwd(),'nearest_neighbours')
    for test_image_path,idx in zip(distance_dict,range(len(distance_dict))):
        print('Nearest neighbours for : {}'.format(test_image_path))
        distances = distance_dict[test_image_path] # Extract the sub-dictionary we want to sort on distances
        ordered_list = [(distances[k],k) for k in sorted(distances, key=distances.get)]
        closest_images = ordered_list[:top_n]
        image_list = []
        image_list.append(read_and_crop_image(test_image_path)) # Append the original image first
        for items in closest_images:
            image_list.append(read_and_crop_image(items[1])) # Append closest images

        merge_and_save(image_list = image_list,idx = idx,root_dir = root_dir)

if __name__ == '__main__':
    distances = fetch_dict('distance_dict.pkl')
    find_similar_faces(distance_dict = distances)


