"""

Using the dictionary generated by the distance calculation script,
find top-n similar images from the training set for each test set image

"""
import scipy.misc
import cv2
import pickle
import os
import numpy as np
import collections
import shutil

models = ['dcgan.jpg','wgan.jpg','dcgan-gp.jpg','wgan-gp.jpg','dcgan-cons.jpg']

def center_crop(im, output_size):
    output_height, output_width = output_size
    h, w = im.shape[:2]
    short_edge = min(h,w)
    if h < output_height and w < output_width:
        raise ValueError("image is small")

    offset_h = int((h - short_edge) / 2)
    offset_w = int((w - short_edge) / 2)
    center_crop =  im[offset_h:offset_h+short_edge, offset_w:offset_w+short_edge, :]
    resized_crop = scipy.misc.imresize(center_crop,[output_width+18,output_height+18]) # Add some wiggle room
    start_pixel = 10
    end_pixel = output_width + 10 # Assuming that width and height are same !!
    centered_image = resized_crop[start_pixel:end_pixel,start_pixel:end_pixel]
    return centered_image

def fetch_dict(fname):
    try:
        with open(fname,'rb') as f:
            return collections.OrderedDict(sorted(pickle.load(f).items()))
    except:
        print('Pkl file not found')


def read_and_crop_image(fname):
    return center_crop(im = cv2.imread(fname),output_size=[64,64])


def merge_and_save(image_list,generated_image_list,idx,root_dir):

    """
    Create an image mosiac.
    1st row : Original Image + Nearest Neighbours
    2nd row : In-paintings
    """


    if len(image_list) < 10:
        print('No neighbors for image {}'.format(idx))
        return

    filename = os.path.join(root_dir,'sim_images_for_{}.jpg'.format(idx))
    frame_width = int(64*len(image_list))
    frame_height = int(64*2) # 2 "rows" of images
    frame_channels = 3
    img = np.zeros((frame_height,frame_width,frame_channels))
    for image,index in zip(image_list,range(len(image_list))):
        x_pos = index*64
        img[0:int((frame_height/2)),x_pos:x_pos+64,:] = image


    for image,index in zip(generated_image_list,range(len(generated_image_list))):
        x_pos = index*64
        if image.shape[0] == 64 and image.shape[1] == 64 and image.shape[2] == 3:
            img[int((frame_height/2)):frame_height,x_pos:x_pos+64,:] = image
        else:
            print('Generated Image ({}) for original image {} is not of the correct shape'.format(models[index],idx))

    scipy.misc.imsave(filename,img)

def get_image_id(fname):
    """
    Helper function to get image ID from filename

    """
    return int(fname.split('/')[-2])

def find_similar_faces(distance_dict,top_n=10):
    """
    distance_dict = {test_image_path : {training_image_path : distance}}

    """
    root_dir = os.path.join(os.getcwd(),'nearest_neighbours')

    if os.path.exists(root_dir) is True:
        shutil.rmtree(root_dir)

    os.makedirs(root_dir)

    for test_image_path in distance_dict:
        print('Nearest neighbours for : {}'.format(test_image_path))
        distances = distance_dict[test_image_path] # Extract the sub-dictionary we want to sort on distances
        ordered_list = [(distances[k],k) for k in sorted(distances, key=distances.get)]
        closest_images = ordered_list[:top_n]
        image_list = []
        image_list.append(read_and_crop_image(test_image_path)) # Append the original image first
        for items in closest_images:
            image_list.append(read_and_crop_image(items[1])) # Append closest images

        generated_image_root = test_image_path.replace('original.jpg','gen')
        # Append in-painted images
        generated_image_list = []
        for model in models:
            generated_image_list.append(read_and_crop_image(os.path.join(generated_image_root,model)))

        merge_and_save(image_list = image_list,generated_image_list = generated_image_list,idx = get_image_id(test_image_path),root_dir = root_dir)

if __name__ == '__main__':
    distances = fetch_dict('distance_dict.pkl')
    find_similar_faces(distance_dict = distances)


